export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import { getTenant } from '@/lib/tenant';
import { supabaseAdmin } from '@/lib/supabaseAdmin';

export async function GET(req: NextRequest) {
    try {
        const url = new URL(req.url);
        const slugParam = url.searchParams.get('tenant');
        const date = url.searchParams.get('date'); // YYYY-MM-DD
        const zoneId = url.searchParams.get('zoneId');

        if (!date) {
            return NextResponse.json({ ok: false, message: 'Missing date' }, { status: 400 });
        }

        const tenant = await getTenant(slugParam, { path: url.pathname });
        if (!tenant?.id) {
            return NextResponse.json({ ok: false, message: 'Business not found' }, { status: 404 });
        }

        const social = (tenant as any)?.social || {};
        const reservationsEnabled = social?.reservations_enabled !== false;
        if (!reservationsEnabled) {
            return NextResponse.json({ ok: true, blocked: [], message: 'Reservations disabled' });
        }

        // Config defaults
        const globalCapacity = Number(social?.reservations_capacity || 0);
        const avgDuration = Number(social?.reservations_duration || 90);

        // Find Zone Capacity
        let capacity = globalCapacity;
        let targetZone = null;
        if (zoneId) {
            const zones = Array.isArray(social?.reservations_zones) ? social.reservations_zones : [];
            targetZone = zones.find((z: any) => z.id === zoneId && z.enabled);
            if (targetZone) {
                capacity = targetZone.capacity;
            }
        }

        // Safety
        if (capacity <= 0) {
            // If capacity 0, maybe configured wrong? Assume 9999 or blocked?
            // If truly 0, then blocked.
            // Let's assume if 0, it means unlimited if global, but for zones usually means 0.
            // Let's respect it.
        }

        // Fetch existing reservations for the day
        const dayStartUtc = new Date(`${date}T00:00:00.000Z`).toISOString();
        const dayEndUtc = new Date(`${date}T23:59:59.999Z`).toISOString();

        const { data: existing, error } = await supabaseAdmin
            .from('reservations')
            .select('reserved_at, party_size, notes')
            .eq('business_id', tenant.id)
            .gte('reserved_at', dayStartUtc)
            .lte('reserved_at', dayEndUtc)
            .neq('status', 'cancelled');

        if (error) throw error;

        // Filter by zone first
        const relevantReservations = (existing || []).filter(res => {
            if (!targetZone) return true; // Global -> count everything (or refined logic)

            // Zone Match Logic (Same as POST)
            const noteLower = (res.notes || '').toLowerCase();
            const targetId = targetZone.id.toLowerCase();
            const targetName = targetZone.name.toLowerCase();

            if (noteLower.includes(`[id:${targetId}]`)) return true;
            if (noteLower.includes(`zona: ${targetName}`)) return true;
            if (!noteLower.includes('[id:') && !noteLower.includes('zona:')) return true; // Legacy/NoZone counts

            return false;
        });

        // We can't pre-calculate "blocked slots" easily because slots are dynamic intervals (13:00, 13:15, 13:30...)
        // The frontend sends us "Start Time", we need to know if that start time is valid.
        // Ideally, we return the LIST of occupied counts per minute? No too heavy.
        // Better: Return the LIST of relevant reservations (start, duration, pax) and let client compute?
        // Security: exposing party_size and times might be leaking info.

        // Approach: The client knows the slots it wants to show (e.g. generated by interval).
        // But the client doesn't send them to us here.
        // So we should return a "Busy Map" or simplified data.

        // Simplest for now: Return the list of "Busy Intervals" { startMs, endMs, currentPax }
        // Frontend can iterate its slots and check overlaps.

        const busyIntervals = relevantReservations.map(res => {
            const start = new Date(res.reserved_at).getTime();
            return {
                start,
                end: start + (avgDuration * 60000),
                pax: res.party_size || 0
            };
        });

        return NextResponse.json({
            ok: true,
            capacity,
            busy: busyIntervals,
            avgDuration // Client needs this to check its own slot duration overlap? No, "busy" already has duration. 
            // But checking a NEW slot of X duration against busy intervals requires knowing the new slot duration.
        });

    } catch (e: any) {
        console.error(e);
        return NextResponse.json({ ok: false, error: e.message }, { status: 500 });
    }
}
